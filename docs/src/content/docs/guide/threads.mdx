---
title: Threads
description: The Thread utility class for managing conversation history.
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

# Threads

`Thread` is an **optional** utility class for managing conversation history. UPP does not manage threads internally—users control their own history.

## Thread Interface

```typescript
class Thread {
  /** Create a new thread, optionally with initial messages */
  constructor(messages?: Message[]);

  /** Unique thread identifier */
  readonly id: string;

  /** All messages in the thread */
  readonly messages: readonly Message[];

  /** Number of messages */
  readonly length: number;

  /** Append messages from a turn */
  append(turn: Turn): this;

  /** Add raw messages */
  push(...messages: Message[]): this;

  /** Add a user message */
  user(content: string | ContentBlock[]): this;

  /** Add an assistant message */
  assistant(content: string | ContentBlock[]): this;

  /** Get messages by type */
  filter(type: MessageType): Message[];

  /** Get the last N messages */
  tail(count: number): Message[];

  /** Create a new thread with a subset of messages */
  slice(start?: number, end?: number): Thread;

  /** Clear all messages */
  clear(): this;

  /** Convert to plain message array */
  toMessages(): Message[];

  /** Serialize to JSON */
  toJSON(): ThreadJSON;

  /** Deserialize from JSON */
  static fromJSON(json: ThreadJSON): Thread;

  /** Iterate over messages */
  [Symbol.iterator](): Iterator<Message>;
}
```

## Basic Usage

```typescript
import { llm, Thread } from '@providerprotocol/ai';
import { anthropic } from '@providerprotocol/ai/anthropic';

const claude = llm({
  model: anthropic('claude-sonnet-4-20250514'),
  system: 'You are a helpful assistant.',
});

// Create a new thread
const thread = new Thread();

// First turn
const turn1 = await claude.generate(thread, 'My name is Bob.');
thread.append(turn1);

// Second turn (history preserved)
const turn2 = await claude.generate(thread, 'What did I just tell you?');
thread.append(turn2);

console.log(turn2.response.text); // "You told me your name is Bob."
console.log(thread.length);       // 4 messages
```

## Using Raw Arrays

Threads are optional—you can use plain arrays instead:

```typescript
const messages: Message[] = [];

const turn = await claude.generate(messages, 'Hello!');
messages.push(...turn.messages);

const turn2 = await claude.generate(messages, 'What did I say?');
messages.push(...turn2.messages);
```

<Aside type="tip">
Choose `Thread` for the convenience methods, or raw arrays for simplicity. Both work equally well with `generate()` and `stream()`.
</Aside>

## Thread Methods

### Building Threads

```typescript
const thread = new Thread();

// Add messages programmatically
thread.user('Hello!');
thread.assistant('Hi there! How can I help?');
thread.user('What is 2+2?');

// Or add from turns
const turn = await claude.generate(thread, 'Continue...');
thread.append(turn);
```

### Filtering and Slicing

```typescript
// Get only user messages
const userMessages = thread.filter('user');

// Get last 10 messages
const recent = thread.tail(10);

// Create a new thread from a subset
const subset = thread.slice(-20); // Last 20 messages
```

### Clearing

```typescript
// Clear all messages
thread.clear();
```

## Serialization

Threads can be serialized for storage and restored later:

<Tabs>
  <TabItem label="Save">
```typescript
// Serialize to JSON
const json = thread.toJSON();

// Store in localStorage
localStorage.setItem('conversation', JSON.stringify(json));

// Or save to a file
await Bun.write('conversation.json', JSON.stringify(json));
```
  </TabItem>
  <TabItem label="Restore">
```typescript
// Restore from localStorage
const json = JSON.parse(localStorage.getItem('conversation')!);
const restored = Thread.fromJSON(json);

// Continue the conversation
const turn = await claude.generate(restored, 'Continue where we left off');
restored.append(turn);
```
  </TabItem>
</Tabs>

## Thread JSON Format

```typescript
interface ThreadJSON {
  id: string;
  messages: MessageJSON[];
  createdAt: string;
  updatedAt: string;
}

interface MessageJSON {
  id: string;
  type: MessageType;
  content: ContentBlock[];
  toolCalls?: ToolCall[];
  results?: ToolResult[];
  metadata?: MessageMetadata;
  timestamp: string;
}
```

## Iteration

Threads are iterable:

```typescript
for (const message of thread) {
  console.log(`${message.type}: ${message.text}`);
}

// Or use spread operator
const allMessages = [...thread];
```

## When to Use Thread

| Use Case | Recommendation |
|----------|----------------|
| Simple one-off queries | Raw array or no history |
| Multi-turn conversations | Thread |
| Persistent conversations | Thread with serialization |
| Custom history management | Raw array |
| Context window management | Thread with `slice()` and `tail()` |

<Aside type="note">
UPP intentionally does not manage conversation history internally. This gives you full control over context management, pruning, and storage.
</Aside>
