---
title: Messages
description: Message types and content blocks in UPP.
---

import { Aside, Badge, Card, CardGrid } from '@astrojs/starlight/components';

# Messages

<Badge text="UPP-1.2.0" variant="note" />

## Message Hierarchy

Messages are represented as a type hierarchy, allowing type-safe handling and provider-specific transformations.

**Base Message Structure:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Unique message identifier |
| `timestamp` | Timestamp | When the message was created |
| `metadata` | Map? | Provider-specific metadata, namespaced by provider |
| `type` | MessageType | Message type discriminator |
| `text` | String | Convenience accessor - concatenates all text blocks with "\n\n" |
| `images` | List&lt;ImageBlock&gt; | Convenience accessor - returns all image blocks |
| `audio` | List&lt;AudioBlock&gt; | Convenience accessor - returns all audio blocks |
| `video` | List&lt;VideoBlock&gt; | Convenience accessor - returns all video blocks |

**MessageType Values:**

| Value | Description |
|-------|-------------|
| `user` | User input message |
| `assistant` | Assistant response message |
| `tool_result` | Result of tool execution |

**MessageMetadata Structure:**

Provider-namespaced metadata. Each provider defines its own metadata shape, enabling provider-specific features without affecting other providers. The structure is `Map&lt;String, Map&gt;` where the outer key is the provider name.

```text
{
  providerName: { key: value, ... }
}
```

Providers MUST ignore metadata namespaces they don't recognize. Message metadata is passed through to the provider's native format where supported. Consult individual provider documentation for supported metadata options.

## Message Types

**UserMessage:**

| Field | Type | Description |
|-------|------|-------------|
| `type` | "user" | Always "user" |
| `content` | List&lt;UserContent&gt; | Content blocks |

`UserContent` can be: `TextBlock`, `ImageBlock`, `AudioBlock`, `VideoBlock`, `BinaryBlock`

Constructor accepts either a string (converted to TextBlock) or array of content blocks.

**AssistantMessage:**

| Field | Type | Description |
|-------|------|-------------|
| `type` | "assistant" | Always "assistant" |
| `content` | List&lt;AssistantContent&gt; | Content blocks |
| `toolCalls` | List&lt;ToolCall&gt;? | Tool calls requested by the model |
| `hasToolCalls` | Boolean | Convenience: true if toolCalls is non-empty |

`AssistantContent` can be: `TextBlock`, `ImageBlock`, `AudioBlock`, `VideoBlock`

<Aside type="note">
Models can return both text AND tool calls in a single response (e.g., "I'll check the weather for you." + tool call). `AssistantMessage` handles both cases.
</Aside>

**ToolResultMessage:**

| Field | Type | Description |
|-------|------|-------------|
| `type` | "tool_result" | Always "tool_result" |
| `results` | List&lt;ToolResult&gt; | Tool execution results |

**ToolCall Structure:**

| Field | Type | Description |
|-------|------|-------------|
| `toolCallId` | String | Provider-assigned ID |
| `toolName` | String | Name of tool to invoke |
| `arguments` | Map | Arguments for the tool |

**ToolResult Structure:**

| Field | Type | Description |
|-------|------|-------------|
| `toolCallId` | String | Matching tool_call_id |
| `result` | Any | Result value |
| `isError` | Boolean? | Whether this is an error result (default false) |

**MessageOptions Structure:**

Optional configuration passed to message constructors.

| Field | Type | Description |
|-------|------|-------------|
| `id` | String? | Custom message ID (auto-generated if not provided) |
| `metadata` | MessageMetadata? | Provider-namespaced metadata |

**Message Construction:**

All message types accept an optional `MessageOptions` parameter:

```text
// UserMessage construction
UserMessage(content: String | List&lt;UserContent&gt;, options?: MessageOptions)

// AssistantMessage construction
AssistantMessage(content: String | List&lt;AssistantContent&gt;, toolCalls?: List&lt;ToolCall&gt;, options?: MessageOptions)

// ToolResultMessage construction
ToolResultMessage(results: List&lt;ToolResult&gt;, options?: MessageOptions)
```

## Content Blocks

Content blocks represent discrete pieces of content within messages.

**TextBlock:**

```text
{
  type: "text",
  text: "Hello, world!"
}
```

**ImageBlock:**

```text
{
  type: "image",
  source: ImageSource,
  mimeType: "image/png",
  width: 1024,      // optional
  height: 768       // optional
}
```

**ImageSource Variants:**

```text
// Base64 encoded
{ type: "base64", data: "iVBORw0KGgo..." }

// URL reference
{ type: "url", url: "https://example.com/image.png" }

// Raw bytes
{ type: "bytes", data: <binary data> }
```

**AudioBlock:**

```text
{
  type: "audio",
  data: <binary data>,
  mimeType: "audio/wav",
  duration: 5.5     // optional, seconds
}
```

**VideoBlock:**

```text
{
  type: "video",
  data: <binary data>,
  mimeType: "video/mp4",
  duration: 30.0,   // optional, seconds
  width: 1920,      // optional
  height: 1080      // optional
}
```

**BinaryBlock:**

```text
{
  type: "binary",
  data: <binary data>,
  mimeType: "application/pdf",
  metadata: {}      // optional
}
```

<Aside type="note">
`BinaryBlock` is only valid in `UserContent` (user inputs). Models do not produce binary outputs directly; they return text, images, audio, or video blocks. Applications sending arbitrary file data to models MUST use `BinaryBlock` in user messages.
</Aside>

## Message Construction

```text
// Text user message
userMsg = UserMessage("Hello, world!")

// User message with image
imageMsg = UserMessage([
  await Image.fromPath("diagram.png"),
  "Please explain this diagram"
])

// User message with URL-based image
urlImageMsg = UserMessage([
  Image.fromUrl("https://example.com/image.png"),
  "What is this?"
])

// Assistant message (text only)
assistantMsg = AssistantMessage("I can help with that!")

// Assistant message with tool calls (typically created by provider)
assistantWithTools = AssistantMessage(
  [{ type: "text", text: "I'll check the weather for you." }],
  [{ toolCallId: "call_123", toolName: "getWeather", arguments: { location: "Tokyo" } }]
)

// Tool result message (created by llm() core after tool execution)
toolResultMsg = ToolResultMessage([
  { toolCallId: "call_123", result: "72Â°F, sunny" }
])
```

## Image Type

Implementations SHOULD provide an `Image` type with factory methods:

**Image Properties:**

| Property | Type | Description |
|----------|------|-------------|
| `source` | ImageSource | The image source |
| `mimeType` | String | MIME type |
| `width` | Integer? | Width in pixels |
| `height` | Integer? | Height in pixels |
| `hasData` | Boolean | True if data is loaded (false for URL sources) |

**Image Methods:**

| Method | Return Type | Description |
|--------|-------------|-------------|
| `toBase64()` | String | Convert to base64 string (throws if URL source) |
| `toDataUrl()` | String | Convert to data URL (throws if URL source) |
| `toBytes()` | Bytes | Get raw bytes (throws if URL source) |

**Image Factory Methods:**

| Method | Description |
|--------|-------------|
| `Image.fromPath(path)` | Create from file path (reads file into memory) |
| `Image.fromUrl(url, mimeType?)` | Create from URL reference (does not fetch) |
| `Image.fromBytes(data, mimeType)` | Create from raw bytes |
| `Image.fromBase64(base64, mimeType)` | Create from base64 string |

## Type Guards

UPP implementations SHOULD provide type guard functions for message handling:

```text
isUserMessage(msg: Message) -> Boolean
isAssistantMessage(msg: Message) -> Boolean
isToolResultMessage(msg: Message) -> Boolean

// Usage
for msg in turn.messages {
  if (isAssistantMessage(msg)) {
    print("Response:", msg.text)
    if (msg.hasToolCalls) {
      print("Tool calls:", msg.toolCalls)
    }
  } else if (isToolResultMessage(msg)) {
    print("Tool results:", msg.results)
  }
}
```