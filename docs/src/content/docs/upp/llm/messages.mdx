---
title: Messages
description: Message types and content blocks in UPP.
---

import { Aside, Badge, Card, CardGrid } from '@astrojs/starlight/components';

# Messages

<Badge text="UPP-1.2.0" variant="note" />

## Message Hierarchy

Messages are represented as a type hierarchy, allowing type-safe handling and provider-specific transformations.

**Base Message Structure:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Unique message identifier |
| `timestamp` | Timestamp | When the message was created |
| `metadata` | Map? | Provider-specific metadata, namespaced by provider |
| `type` | MessageType | Message type discriminator |
| `text` | String | Convenience accessor - concatenates all text blocks with "\n\n" |
| `images` | List&lt;ImageBlock&gt; | Convenience accessor - returns all image blocks |
| `documents` | List&lt;DocumentBlock&gt; | Convenience accessor - returns all document blocks |
| `audio` | List&lt;AudioBlock&gt; | Convenience accessor - returns all audio blocks |
| `video` | List&lt;VideoBlock&gt; | Convenience accessor - returns all video blocks |

**MessageType Values:**

| Value | Description |
|-------|-------------|
| `user` | User input message |
| `assistant` | Assistant response message |
| `tool_result` | Result of tool execution |

**MessageMetadata Structure:**

Provider-namespaced metadata. Each provider defines its own metadata shape, enabling provider-specific features without affecting other providers. The structure is `Map&lt;String, Map&gt;` where the outer key is the provider name.

```text
{
  providerName: { key: value, ... }
}
```

Providers MUST ignore metadata namespaces they don't recognize. Message metadata is passed through to the provider's native format where supported. Consult individual provider documentation for supported metadata options.

## Message Types

**UserMessage:**

| Field | Type | Description |
|-------|------|-------------|
| `type` | "user" | Always "user" |
| `content` | List&lt;UserContent&gt; | Content blocks |

`UserContent` can be: `TextBlock`, `ImageBlock`, `DocumentBlock`, `AudioBlock`, `VideoBlock`, `BinaryBlock`

Constructor accepts either a string (converted to TextBlock) or array of content blocks.

**AssistantMessage:**

| Field | Type | Description |
|-------|------|-------------|
| `type` | "assistant" | Always "assistant" |
| `content` | List&lt;AssistantContent&gt; | Content blocks |
| `toolCalls` | List&lt;ToolCall&gt;? | Tool calls requested by the model |
| `hasToolCalls` | Boolean | Convenience: true if toolCalls is non-empty |

`AssistantContent` can be: `TextBlock`, `ReasoningBlock`, `ImageBlock`, `AudioBlock`, `VideoBlock`

<Aside type="note">
Models can return both text AND tool calls in a single response (e.g., "I'll check the weather for you." + tool call). `AssistantMessage` handles both cases.
</Aside>

**ToolResultMessage:**

| Field | Type | Description |
|-------|------|-------------|
| `type` | "tool_result" | Always "tool_result" |
| `results` | List&lt;ToolResult&gt; | Tool execution results |

**ToolCall Structure:**

| Field | Type | Description |
|-------|------|-------------|
| `toolCallId` | String | Provider-assigned ID |
| `toolName` | String | Name of tool to invoke |
| `arguments` | Map | Arguments for the tool |

**ToolResult Structure:**

| Field | Type | Description |
|-------|------|-------------|
| `toolCallId` | String | Matching tool_call_id |
| `result` | Any | Result value |
| `isError` | Boolean? | Whether this is an error result (default false) |

**MessageOptions Structure:**

Optional configuration passed to message constructors.

| Field | Type | Description |
|-------|------|-------------|
| `id` | String? | Custom message ID (auto-generated if not provided) |
| `metadata` | MessageMetadata? | Provider-namespaced metadata |

**Message Construction:**

All message types accept an optional `MessageOptions` parameter:

```text
// UserMessage construction
UserMessage(content: String | List&lt;UserContent&gt;, options?: MessageOptions)

// AssistantMessage construction
AssistantMessage(content: String | List&lt;AssistantContent&gt;, toolCalls?: List&lt;ToolCall&gt;, options?: MessageOptions)

// ToolResultMessage construction
ToolResultMessage(results: List&lt;ToolResult&gt;, options?: MessageOptions)
```

## Content Blocks

Content blocks represent discrete pieces of content within messages.

**TextBlock:**

```text
{
  type: "text",
  text: "Hello, world!"
}
```

**ReasoningBlock:**

Contains model reasoning/thinking content from extended thinking or chain-of-thought models.
This content represents the model's internal reasoning process before generating the final response.

```text
{
  type: "reasoning",
  text: "Let me think about this step by step..."
}
```

<Aside type="note">
Reasoning blocks are always placed before text blocks in assistant message content. Multi-turn context preservation for reasoning (signatures, encrypted content) is handled via provider-specific metadata fields.
</Aside>

**ImageBlock:**

```text
{
  type: "image",
  source: ImageSource,
  mimeType: "image/png",
  width: 1024,      // optional
  height: 768       // optional
}
```

**ImageSource Variants:**

```text
// Base64 encoded
{ type: "base64", data: "iVBORw0KGgo..." }

// URL reference
{ type: "url", url: "https://example.com/image.png" }

// Raw bytes
{ type: "bytes", data: <binary data> }
```

**DocumentBlock:**

```text
{
  type: "document",
  source: DocumentSource,
  mimeType: "application/pdf",  // or "text/plain"
  title: "Annual Report"        // optional, used for citations
}
```

**DocumentSource Variants:**

```text
// Base64 encoded PDF
{ type: "base64", data: "JVBERi0xLjQK..." }

// URL reference to PDF
{ type: "url", url: "https://example.com/document.pdf" }

// Plain text content
{ type: "text", data: "This is the document content..." }
```

**AudioBlock:**

```text
{
  type: "audio",
  data: <binary data>,
  mimeType: "audio/wav",
  duration: 5.5     // optional, seconds
}
```

**VideoBlock:**

```text
{
  type: "video",
  data: <binary data>,
  mimeType: "video/mp4",
  duration: 30.0,   // optional, seconds
  width: 1920,      // optional
  height: 1080      // optional
}
```

**BinaryBlock:**

```text
{
  type: "binary",
  data: <binary data>,
  mimeType: "application/pdf",
  metadata: {}      // optional
}
```

<Aside type="note">
`BinaryBlock` is only valid in `UserContent` (user inputs). Models do not produce binary outputs directly; they return text, images, audio, or video blocks. Applications sending arbitrary file data to models MUST use `BinaryBlock` in user messages.
</Aside>

## Message Construction

```text
// Text user message
userMsg = UserMessage("Hello, world!")

// User message with image
imageMsg = UserMessage([
  await Image.fromPath("diagram.png"),
  "Please explain this diagram"
])

// User message with URL-based image
urlImageMsg = UserMessage([
  Image.fromUrl("https://example.com/image.png"),
  "What is this?"
])

// Assistant message (text only)
assistantMsg = AssistantMessage("I can help with that!")

// Assistant message with tool calls (typically created by provider)
assistantWithTools = AssistantMessage(
  [{ type: "text", text: "I'll check the weather for you." }],
  [{ toolCallId: "call_123", toolName: "getWeather", arguments: { location: "Tokyo" } }]
)

// Tool result message (created by llm() core after tool execution)
toolResultMsg = ToolResultMessage([
  { toolCallId: "call_123", result: "72Â°F, sunny" }
])
```

## Image Type

Implementations SHOULD provide an `Image` type with factory methods:

**Image Properties:**

| Property | Type | Description |
|----------|------|-------------|
| `source` | ImageSource | The image source |
| `mimeType` | String | MIME type |
| `width` | Integer? | Width in pixels |
| `height` | Integer? | Height in pixels |
| `hasData` | Boolean | True if data is loaded (false for URL sources) |

**Image Methods:**

| Method | Return Type | Description |
|--------|-------------|-------------|
| `toBase64()` | String | Convert to base64 string (throws if URL source) |
| `toDataUrl()` | String | Convert to data URL (throws if URL source) |
| `toBytes()` | Bytes | Get raw bytes (throws if URL source) |

**Image Factory Methods:**

| Method | Description |
|--------|-------------|
| `Image.fromPath(path)` | Create from file path (reads file into memory) |
| `Image.fromUrl(url, mimeType?)` | Create from URL reference (does not fetch) |
| `Image.fromBytes(data, mimeType)` | Create from raw bytes |
| `Image.fromBase64(base64, mimeType)` | Create from base64 string |
| `Image.fromBlock(block)` | Create from an existing ImageBlock |

## Document Type

Implementations SHOULD provide a `Document` type with factory methods for PDF and text documents:

**Document Properties:**

| Property | Type | Description |
|----------|------|-------------|
| `source` | DocumentSource | The document source |
| `mimeType` | String | MIME type (`application/pdf` or `text/plain`) |
| `title` | String? | Optional document title (for citations) |
| `hasData` | Boolean | True if data is loaded (false for URL sources) |
| `isPdf` | Boolean | True if document is PDF |
| `isText` | Boolean | True if document is plain text |

**Document Methods:**

| Method | Return Type | Description |
|--------|-------------|-------------|
| `toBase64()` | String | Convert to base64 string (throws if not base64 source) |
| `toText()` | String | Get text content (throws if not text source) |
| `toUrl()` | String | Get URL (throws if not URL source) |
| `toBlock()` | DocumentBlock | Convert to content block for messages |

**Document Factory Methods:**

| Method | Description |
|--------|-------------|
| `Document.fromPath(path, title?)` | Create from file path (reads and base64-encodes) |
| `Document.fromUrl(url, title?)` | Create from URL reference (PDF only, does not fetch) |
| `Document.fromBase64(base64, mimeType, title?)` | Create from base64 string |
| `Document.fromText(text, title?)` | Create from plain text content |
| `Document.fromBlock(block)` | Create from an existing DocumentBlock |

## Audio Type

Implementations SHOULD provide an `Audio` type with factory methods:

**Audio Properties:**

| Property | Type | Description |
|----------|------|-------------|
| `data` | Bytes | The audio data as raw bytes |
| `mimeType` | String | MIME type (e.g., `audio/mp3`, `audio/wav`) |
| `duration` | Number? | Duration in seconds |
| `size` | Integer | Size in bytes |

**Audio Methods:**

| Method | Return Type | Description |
|--------|-------------|-------------|
| `toBase64()` | String | Convert to base64 string |
| `toDataUrl()` | String | Convert to data URL |
| `toBytes()` | Bytes | Get raw bytes |
| `toBlock()` | AudioBlock | Convert to content block for messages |

**Audio Factory Methods:**

| Method | Description |
|--------|-------------|
| `Audio.fromPath(path, duration?)` | Create from file path (reads file into memory) |
| `Audio.fromBytes(data, mimeType, duration?)` | Create from raw bytes |
| `Audio.fromBase64(base64, mimeType, duration?)` | Create from base64 string |
| `Audio.fromBlock(block)` | Create from an existing AudioBlock |

## Video Type

Implementations SHOULD provide a `Video` type with factory methods:

**Video Properties:**

| Property | Type | Description |
|----------|------|-------------|
| `data` | Bytes | The video data as raw bytes |
| `mimeType` | String | MIME type (e.g., `video/mp4`, `video/webm`) |
| `duration` | Number? | Duration in seconds |
| `width` | Integer? | Width in pixels |
| `height` | Integer? | Height in pixels |
| `size` | Integer | Size in bytes |

**Video Methods:**

| Method | Return Type | Description |
|--------|-------------|-------------|
| `toBase64()` | String | Convert to base64 string |
| `toDataUrl()` | String | Convert to data URL |
| `toBytes()` | Bytes | Get raw bytes |
| `toBlock()` | VideoBlock | Convert to content block for messages |

**Video Factory Methods:**

| Method | Description |
|--------|-------------|
| `Video.fromPath(path, options?)` | Create from file path (reads file into memory) |
| `Video.fromBytes(data, mimeType, options?)` | Create from raw bytes |
| `Video.fromBase64(base64, mimeType, options?)` | Create from base64 string |
| `Video.fromBlock(block)` | Create from an existing VideoBlock |

Options for Video factory methods may include `duration`, `width`, and `height`.

## Type Guards

UPP implementations SHOULD provide type guard functions for message handling:

```text
isUserMessage(msg: Message) -> Boolean
isAssistantMessage(msg: Message) -> Boolean
isToolResultMessage(msg: Message) -> Boolean

// Usage
for msg in turn.messages {
  if (isAssistantMessage(msg)) {
    print("Response:", msg.text)
    if (msg.hasToolCalls) {
      print("Tool calls:", msg.toolCalls)
    }
  } else if (isToolResultMessage(msg)) {
    print("Tool results:", msg.results)
  }
}
```