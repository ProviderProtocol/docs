---
title: Conformance Levels
description: Provider conformance requirements for each modality.
---

import { Aside, Badge } from '@astrojs/starlight/components';

# Conformance Levels

Providers may implement one or more modalities. For each modality, conformance is defined at multiple levels.

## LLM Conformance

### Level 1: Core <Badge text="Required" variant="caution" />

- Declare `LLMCapabilities` accurately for the provider's API
- Text input/output via `generate()` method
- Return `LLMResponse` with `AssistantMessage` and `TokenUsage`
- Basic configuration pass-through (`params`)
- Error normalization to `UPPError` with correct `modality: 'llm'`
- System prompt handling per vendor requirements

### Level 2: Streaming

- `stream()` method implementation
- Proper `StreamEvent` emission with correct `StreamEventType`
- `LLMStreamResult` with `response` promise
- Support for `message_start`, `text_delta`, `message_stop` at minimum

### Level 3: Tools

- Tool definition transformation (JSON Schema to vendor format)
- Tool call detection in responses (`AssistantMessage.toolCalls`)
- Tool result handling (`ToolResultMessage` transformation)

<Aside type="note">
Tool execution loop is handled by `llm()` core, not providers.
</Aside>

### Level 4: Structured Output

- Transform `structure` schema to vendor format
- Enable vendor's structured output mode
- Parse and return structured data as JSON

### Level 5: Multimodal Input

- Image input handling (base64, URL conversion) if `capabilities.imageInput: true`
- Audio input handling if `capabilities.audioInput: true`
- Video input handling if `capabilities.videoInput: true`

## Embedding Conformance

### Level 1: Core <Badge text="Required" variant="caution" />

- `embed()` method for single inputs
- Return `EmbeddingResponse` with vectors and usage
- Text input support
- Error normalization with `modality: 'embedding'`

### Level 2: Batch

- Batch embedding via provider's batch API
- Respect `maxBatchSize` limits
- Aggregate usage reporting

### Level 3: Multimodal

- Image embedding support (if vendor supports)
- Declare supported inputs in `supportedInputs`

## Image Conformance

### Level 1: Core <Badge text="Required" variant="caution" />

- `generate()` method for text-to-image
- Return `ImageResponse` with `GeneratedImage` array
- Declare capabilities in `ImageCapabilities`
- Error normalization with `modality: 'image'`

### Level 2: Editing

- `edit()` method for inpainting (if `capabilities.edit`)
- Mask handling

### Level 3: Variations

- `vary()` method (if `capabilities.vary`)
- Strength/count parameters

### Level 4: Streaming

- `stream()` method (if `capabilities.streaming`)
- Progress and preview events

### Level 5: Advanced

- `upscale()` method (if `capabilities.upscale`)
- Outpainting support (if `capabilities.outpaint`)

## Universal Requirements

### Error Handling

All providers MUST:

- Normalize vendor errors to `UPPError`
- Set appropriate `ErrorCode` based on HTTP status or vendor error type
- Include `provider` name and `modality` in all errors
- Preserve original error as `cause` when available

### Configuration Pass-through

All providers MUST:

- Pass `params` to vendor API without modification (unless transformation required)
- Support custom `baseUrl` for proxies
- Support custom `fetch` implementation
- Respect `timeout` setting
- Use provided `retryStrategy` or sensible default

### Metadata Handling

All providers MUST:

- Namespace their metadata under `metadata.{providerName}`
- Preserve unknown metadata fields during round-trips
- Extract vendor-specific response fields to metadata

## Interoperability Notes

<Aside type="caution" title="Provider-Dependent Features">
The following features are provider-dependent and may not transfer between providers:

- Token counting algorithms and limits
- Specific tool calling formats and behaviors
- Streaming granularity and event types
- Response metadata structure
- Rate limiting behavior and headers
- Supported modalities and model capabilities
- Image size and format support
- Embedding dimensions and normalization
</Aside>

Developers should consult individual provider documentation for feature support details.

## Capability Declaration

Providers SHOULD accurately declare their capabilities:

| Modality | Declaration Method |
|----------|-------------------|
| LLM | Check for method existence |
| Embedding | Declare `supportedInputs` array |
| Image | Declare full `ImageCapabilities` object |

Applications SHOULD check capabilities before using optional features to ensure graceful degradation.

## Example: Checking Conformance

```typescript
const provider = openai;

// Check if LLM is supported
if (provider.modalities.llm) {
  const model = provider.modalities.llm.bind('gpt-4o');
  // LLM Level 1 guaranteed
}

// Check for streaming support
if (typeof model.stream === 'function') {
  // LLM Level 2 supported
}

// Check image capabilities
if (provider.modalities.image) {
  const imageModel = provider.modalities.image.bind('dall-e-3');

  if (imageModel.capabilities.edit && imageModel.edit) {
    // Image Level 2 supported
  }
}
```
