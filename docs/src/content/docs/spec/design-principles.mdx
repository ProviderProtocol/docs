---
title: Design Principles
description: The core design principles that guide UPP's architecture.
---

import { Aside, Card, CardGrid } from '@astrojs/starlight/components';

# Design Principles

UPP is built on a set of core principles that guide every design decision.

## Provider Transparency

Configuration passes through to providers unchanged. UPP does not impose its own defaults or transform model parameters. When no config is supplied, provider defaults apply.

**Rationale:** Developers should reference provider documentation directly. UPP avoids "morphic magic" that obscures what's actually sent to the API.

```typescript
// What you configure is what gets sent
const claude = llm({
  model: anthropic('claude-sonnet-4-20250514'),
  params: {
    temperature: 0.7,      // Sent directly to Anthropic API
    max_tokens: 4096,      // No UPP transformation
  },
});
```

## Explicit Over Magic

UPP favors explicit APIs over implicit behavior:

<CardGrid>
  <Card title="Separate Entry Points">
    No modal switches or runtime detection—use `llm()`, `embedding()`, or `image()` explicitly.
  </Card>
  <Card title="Distinct Methods">
    `generate()` for complete responses, `stream()` for streaming—no await/non-await magic.
  </Card>
  <Card title="User-Managed History">
    Users manage their own conversation history—no hidden state mutation.
  </Card>
  <Card title="Explicit System Prompts">
    System prompts declared at configuration, not buried in message arrays.
  </Card>
</CardGrid>

## Modality-Specific Interfaces

Each modality gets a purpose-built interface optimized for its use case:

| Modality | Interface Style |
|----------|----------------|
| **LLM** | Conversational with messages, turns, streaming, tools |
| **Embedding** | Batch-oriented, returns vectors, no conversation |
| **Image** | Prompt-based, returns images, supports editing/variation |

<Aside type="note">
Forcing all modalities through a single interface creates awkward abstractions. UPP embraces modality-specific design.
</Aside>

## Shared Infrastructure

While interfaces differ, providers share common infrastructure:

```typescript
interface ProviderConfig {
  apiKey?: string | (() => string | Promise<string>) | KeyStrategy;
  baseUrl?: string;
  timeout?: number;
  fetch?: typeof fetch;
  apiVersion?: string;
  retryStrategy?: RetryStrategy;
}
```

This includes:
- **ProviderConfig** for infrastructure/connection settings
- **KeyStrategy** implementations (RoundRobin, Weighted, Dynamic)
- **Error handling** with `UPPError` and `ErrorCode`
- **HTTP utilities** for SSE parsing and request building

## Progressive Complexity

Simple use cases require minimal code. Advanced features are opt-in.

```typescript
// Simple: Just model and prompt
const turn = await llm({ model: anthropic('claude-haiku-4.5') })
  .generate('Hello!');

// Advanced: Full configuration
const claude = llm({
  model: anthropic('claude-sonnet-4-20250514'),
  config: {
    apiKey: new RoundRobinKeys([key1, key2]),
    retryStrategy: new ExponentialBackoff({ maxAttempts: 3 }),
    timeout: 30000,
  },
  params: { temperature: 0.7, max_tokens: 4096 },
  system: 'You are a helpful assistant.',
  tools: [getWeather, searchWeb],
  toolStrategy: { maxIterations: 5 },
});
```

## Interoperability Where Possible

UPP enables provider switching for common operations. However, provider-specific features may not translate.

<Aside type="caution">
The protocol does not guarantee feature parity—it guarantees **interface consistency**. Some provider-specific features won't transfer between providers.
</Aside>

## HTTP-First Provider Implementation

UPP **strongly recommends** that providers wrap vendor REST APIs directly using native HTTP primitives (e.g., `fetch`) rather than depending on first-party vendor SDKs.

**Benefits:**

| Benefit | Description |
|---------|-------------|
| **Minimal dependencies** | Avoid pulling in large SDK packages and their transitive dependencies |
| **Full control** | Direct HTTP access allows providers to manage request/response transformation, streaming, retries, and timeouts without SDK abstractions interfering |
| **Consistency** | All providers follow the same HTTP-based pattern |
| **Transparency** | Developers can inspect exactly what's sent over the wire |
| **Bundle size** | Critical for edge deployments and browser environments |

```typescript
// Provider implementation uses fetch directly
const response = await doFetch(VENDOR_URL, {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${apiKey}` },
  body: JSON.stringify(transformRequest(request)),
}, config);
```

<Aside type="tip">
Providers MAY use vendor SDKs if there's a compelling reason, but this should be the exception.
</Aside>
