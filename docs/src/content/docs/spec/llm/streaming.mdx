---
title: Streaming
description: Real-time streaming responses from LLMs.
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

# Streaming

Streaming allows you to receive LLM responses in real-time as they're generated.

## StreamResult

Streaming returns a `StreamResult` that is both an async iterable and provides access to the final `Turn`:

```typescript
interface StreamResult extends AsyncIterable<StreamEvent> {
  /**
   * Get the complete Turn after streaming finishes.
   * Resolves when the stream completes.
   */
  readonly turn: Promise<Turn>;

  /** Abort the stream */
  abort(): void;
}
```

## StreamEvent

During streaming, providers emit `StreamEvent` objects:

```typescript
interface StreamEvent {
  /** Event type */
  type: StreamEventType;

  /** Index of the content block this event belongs to */
  index: number;

  /** Event data (type-specific) */
  delta: EventDelta;
}

type StreamEventType =
  | 'text_delta'           // Partial text token
  | 'reasoning_delta'      // Reasoning/thinking token
  | 'image_delta'          // Partial image data
  | 'audio_delta'          // Partial audio data
  | 'video_delta'          // Partial video data
  | 'tool_call_delta'      // Partial tool call
  | 'message_start'        // Stream started
  | 'message_stop'         // Stream complete
  | 'content_block_start'  // New content block started
  | 'content_block_stop';  // Content block complete

interface EventDelta {
  text?: string;
  data?: Uint8Array;
  toolCallId?: string;
  toolName?: string;
  argumentsJson?: string;
}
```

## Basic Streaming

```typescript
const claude = llm({
  model: anthropic('claude-sonnet-4-20250514'),
  system: 'You are a helpful assistant.',
});

const history: Message[] = [];

// Stream the response
const stream = claude.stream(history, 'Write a haiku about programming.');

for await (const event of stream) {
  if (event.type === 'text_delta') {
    process.stdout.write(event.delta.text ?? '');
  }
}

// Get the complete turn after streaming
const turn = await stream.turn;
history.push(...turn.messages);
```

## Streaming with Tools

When tools are involved, streaming may pause while tools execute:

```typescript
const stream = claude.stream(history, 'What is the weather in Paris?');

for await (const event of stream) {
  switch (event.type) {
    case 'text_delta':
      process.stdout.write(event.delta.text ?? '');
      break;
    case 'tool_call_delta':
      // Tool call being streamed
      console.log('[tool]', event.delta.toolName);
      break;
    case 'message_stop':
      // A message completed (might be tool call, will continue after tool runs)
      break;
  }
}

const turn = await stream.turn;
console.log('Tool executions:', turn.toolExecutions);
```

## Aborting Streams

You can cancel a stream at any time:

```typescript
const stream = claude.stream(history, 'Write a very long story...');

// Abort after 5 seconds
setTimeout(() => {
  stream.abort();
}, 5000);

try {
  for await (const event of stream) {
    process.stdout.write(event.delta.text ?? '');
  }
} catch (error) {
  if (error instanceof UPPError && error.code === 'CANCELLED') {
    console.log('Stream was cancelled');
  }
}
```

<Aside type="note" title="Abort Behavior with Tools">
When a stream is aborted during a tool execution loop:
- The abort signal propagates to any in-flight tool execution
- Pending tool calls that haven't started are skipped
- The overall generation throws a `CANCELLED` error
</Aside>

## Streaming Event Order

A typical streaming sequence:

```
message_start
  content_block_start (index: 0)
    text_delta "Hello"
    text_delta " world"
    text_delta "!"
  content_block_stop (index: 0)
message_stop
```

With tool calls:

```
message_start
  content_block_start (index: 0)
    text_delta "Let me check..."
  content_block_stop (index: 0)
  content_block_start (index: 1)
    tool_call_delta { toolName: "getWeather" }
    tool_call_delta { argumentsJson: '{"loc' }
    tool_call_delta { argumentsJson: 'ation":"Paris"}' }
  content_block_stop (index: 1)
message_stop
[tool execution happens here]
message_start
  content_block_start (index: 0)
    text_delta "The weather is..."
  content_block_stop (index: 0)
message_stop
```

## Handling All Event Types

<Tabs>
  <TabItem label="Full Handler">
```typescript
const stream = claude.stream(history, prompt);

for await (const event of stream) {
  switch (event.type) {
    case 'message_start':
      console.log('Stream started');
      break;

    case 'content_block_start':
      console.log(`Block ${event.index} started`);
      break;

    case 'text_delta':
      process.stdout.write(event.delta.text ?? '');
      break;

    case 'reasoning_delta':
      console.log('[thinking]', event.delta.text);
      break;

    case 'tool_call_delta':
      console.log('[tool]', event.delta.toolName, event.delta.argumentsJson);
      break;

    case 'content_block_stop':
      console.log(`Block ${event.index} complete`);
      break;

    case 'message_stop':
      console.log('Message complete');
      break;
  }
}
```
  </TabItem>
  <TabItem label="Text Only">
```typescript
const stream = claude.stream(history, prompt);

for await (const event of stream) {
  if (event.type === 'text_delta') {
    process.stdout.write(event.delta.text ?? '');
  }
}

console.log('\nDone!');
```
  </TabItem>
</Tabs>

## Getting the Final Turn

Always access `stream.turn` to get the complete result:

```typescript
const stream = claude.stream(history, 'Hello');

// Print streaming output
for await (const event of stream) {
  if (event.type === 'text_delta') {
    process.stdout.write(event.delta.text ?? '');
  }
}

// Get the final turn
const turn = await stream.turn;

// Now you have access to everything
console.log('Messages:', turn.messages.length);
console.log('Usage:', turn.usage);
console.log('Cycles:', turn.cycles);

// Add to history
history.push(...turn.messages);
```
